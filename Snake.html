<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Snake Game</title>
  <style>
    /* Set up the full height and center content with a dark gradient background */
    html, body {
      height: 100%;
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, #2b2b2b, #1a1a1a);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    /* Canvas styling for the game area */
    canvas {
      border: 2px solid #fff; /* White border around the canvas */
      background-color: #4d4d4d; /* Dark background for the game area */
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.5); /* Light glow effect */
      display: none; /* Hide initially, shown when the game starts */
    }

    /* Menu styling for game settings */
    #menu {
      position: absolute; /* Positioned absolutely for flexibility */
      display: flex; /* Flexbox layout for menu items */
      flex-direction: column; /* Stack items vertically */
      align-items: center; /* Center align items */
      background-color: rgba(0, 0, 0, 0.85); /* Semi-transparent black background */
      padding: 30px; /* Padding inside the menu */
      border: 2px solid #fff; /* White border around the menu */
      border-radius: 10px; /* Rounded corners */
      color: #fff; /* White text color */
      z-index: 1; /* Ensure menu appears above other elements */
      box-shadow: 0 0 30px rgba(0, 0, 0, 0.5); /* Shadow for depth */
    }

    /* Title styling for the menu */
    #menu h2 {
      margin: 0; /* Remove default margin */
      font-size: 24px; /* Title font size */
      color: #0ff; /* Teal color for title */
    }

    /* Label styling for inputs */
    #menu label {
      margin-top: 15px; /* Space above labels */
      font-size: 16px; /* Label font size */
    }

    /* Input styling for number inputs */
    #menu input[type="number"] {
      margin-left: 10px; /* Space between label and input */
      padding: 5px; /* Padding inside input fields */
      width: 60px; /* Fixed width for inputs */
      border: 1px solid #fff; /* White border */
      border-radius: 5px; /* Rounded corners */
      background-color: #333; /* Dark background for inputs */
      color: #fff; /* White text */
    }

    /* Button styling for actions */
    button {
      margin-top: 20px; /* Space above buttons */
      padding: 10px 20px; /* Padding inside buttons */
      background-color: #0ff; /* Teal background for buttons */
      color: black; /* Black text color */
      cursor: pointer; /* Pointer cursor on hover */
      border: none; /* Remove default border */
      border-radius: 5px; /* Rounded corners */
      font-size: 16px; /* Button font size */
      transition: background-color 0.3s; /* Smooth background color change */
    }

    /* Hover effect for buttons */
    button:hover {
      background-color: #0cc; /* Darker teal on hover */
    }

    /* Score display styling */
    #score {
      position: absolute; /* Positioned absolutely for flexibility */
      top: 20px; /* Position from the top */
      right: 20px; /* Position from the right */
      font-size: 24px; /* Font size for score */
      color: #fff; /* White text */
      display: none; /* Hide initially, shown during gameplay */
    }

    /* Final score styling */
    #finalScore {
      margin-top: 20px; /* Space above final score */
      font-size: 18px; /* Font size for final score */
      color: #ff0; /* Yellow color for emphasis */
    }

    /* Info section styling */
    #info {
      display: none; /* Hidden by default, shown when needed */
      background-color: rgba(0, 0, 0, 0.85); /* Semi-transparent background */
      padding: 20px; /* Padding inside info section */
      border-radius: 10px; /* Rounded corners */
      margin-top: 15px; /* Space above info section */
      color: #fff; /* White text */
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5); /* Shadow for depth */
    }

    /* Title styling for the info section */
    #info h3 {
      margin: 0; /* Remove default margin */
      font-size: 20px; /* Font size for info title */
      color: #0ff; /* Teal color for title */
    }

    /* Padding for lists in the info section */
    #info ul {
      padding-left: 20px; /* Indent list items */
    }
  </style>
</head>
<body>

  <!-- Main menu for game settings -->
  <div id="menu">
    <h2>Snake Game</h2>
    
    <!-- Board size input -->
    <label for="boardSize">
      Board Size (10 - 50):
      <input type="number" id="boardSize" value="25" min="10" max="50">
    </label>
    
    <!-- Snake speed input -->
    <label for="speed">
      Snake Speed (1 - 10):
      <input type="number" id="speed" value="5" min="1" max="10">
    </label>
    
    <!-- Multiple apples toggle and input -->
    <label>
      <input type="checkbox" id="multipleApplesToggle" onclick="document.getElementById('appleCount').disabled = !this.checked;"> Enable Multiple Apples
      <input type="number" id="appleCount" value="1" min="1" max="10" disabled>
    </label>
    
    <!-- Power-ups toggle and input -->
    <label>
      <input type="checkbox" id="powerToggle" onclick="document.getElementById('powerInterval').disabled = !this.checked;"> Enable Power-ups
      <input type="number" id="powerInterval" value="15" min="1" max="100" disabled> (Spawn every X seconds)
    </label>
    
    <!-- Start game button -->
    <button onclick="startGame()">Start Game</button>
    <!-- Info button -->
    <button onclick="showInfo()">Info</button>
    
    <!-- Display for final score -->
    <div id="finalScore"></div>
    <!-- Info section -->
    <div id="info">
      <h3>Game Info</h3>
      <p><strong>Snake Colors:</strong> Teal or Cyan (No gameplay effect)</p>
      <p><strong>Apple Colors:</strong> Red or Orange (Collect for points)</p>
      <p><strong>Power-ups:</strong></p>
      <ul>
        <li>Speed Up: Magenta</li>
        <li>Speed Down: Magenta</li>
        <li>Score Up: Magenta</li>
      </ul>
      <button onclick="hideInfo()">Close</button>
    </div>
  </div>
  
  <!-- Score display -->
  <div id="score">Score: 0</div>
  
  <!-- Game canvas -->
  <canvas id="game"></canvas>
  
  <script>
    const canvas = document.getElementById('game'); // Game canvas element
    const context = canvas.getContext('2d'); // 2D rendering context for the canvas
    const menu = document.getElementById('menu'); // Main menu element
    const scoreElement = document.getElementById('score'); // Score display element
    const finalScoreElement = document.getElementById('finalScore'); // Final score display element
    const infoElement = document.getElementById('info'); // Info section element

    let grid = 16; // Size of each grid square
    let count = 0; // Frame count for controlling speed
    let snakeSpeed = 5; // Initial speed of the snake
    let snakeColor = ''; // Variable to store snake color
    let score = 0; // Player's score
    let gameInterval; // Interval for the game loop
    let powerIntervalId; // Interval for spawning power-ups
    let isGameRunning = false; // Flag to track game state

    let snake, apples = [], powers = []; // Initialize snake, apples, and power-ups arrays

    const POWER_TYPES = {
      SPEED_UP: 0,
      SPEED_DOWN: 1,
      SCORE_UP: 2
    };

    // Initialize the game with board size and apple count
    function initGame(boardSize, appleCount) {
      canvas.width = boardSize * grid; // Set canvas width based on board size
      canvas.height = boardSize * grid; // Set canvas height based on board size

      // Initialize the snake at the center of the board
      snake = {
        x: Math.floor(boardSize / 2) * grid,
        y: Math.floor(boardSize / 2) * grid,
        dx: grid, // Snake starts moving right
        dy: 0, // No vertical movement initially
        cells: [], // Array to store snake cells
        maxCells: 4 // Initial length of the snake
      };
      
      apples = []; // Clear previous apples
      for (let i = 0; i < appleCount; i++) {
        spawnApple(); // Spawn apples based on the count
      }
      
      powers = []; // Clear previous power-ups
      snakeColor = getRandomSnakeColor(); // Set random snake color
      score = 0; // Reset score
      updateScore(); // Update score display
    }

    // Start the game with the chosen settings
    function startGame() {
      if (isGameRunning) return; // Prevent starting multiple games

      // Get game settings from the menu
      const boardSize = parseInt(document.getElementById('boardSize').value);
      const speedInput = parseInt(document.getElementById('speed').value);
      const multipleApplesToggle = document.getElementById('multipleApplesToggle').checked;
      const appleCount = multipleApplesToggle ? parseInt(document.getElementById('appleCount').value) : 1;
      const powerToggle = document.getElementById('powerToggle').checked;
      const powerInterval = parseInt(document.getElementById('powerInterval').value) * 1000;

      snakeSpeed = 11 - speedInput; // Convert input speed to actual game speed
      grid = Math.floor(400 / boardSize); // Set grid size based on board size
      if (400 % boardSize !== 0) {
        alert('Board size must evenly divide 400 for proper grid alignment.'); // Alert if board size is invalid
        return;
      }

      initGame(boardSize, appleCount); // Initialize the game
      menu.style.display = 'none'; // Hide the menu
      canvas.style.display = 'block'; // Show the game canvas
      scoreElement.style.display = 'block'; // Show the score display
      
      gameInterval = setInterval(loop, snakeSpeed * 100); // Start the game loop based on snake speed
      
      if (powerToggle) {
        powerIntervalId = setInterval(spawnPower, powerInterval); // Start spawning power-ups if enabled
      }
      
      isGameRunning = true; // Set game as running
    }

    // Spawn a new apple at a random position
    function spawnApple() {
      let newApple;
      do {
        newApple = {
          x: getRandomInt(0, canvas.width / grid) * grid, // Random x position
          y: getRandomInt(0, canvas.height / grid) * grid, // Random y position
          color: getRandomAppleColor() // Random color for the apple
        };
      } while (isOccupied(newApple.x, newApple.y)); // Ensure the position is not occupied
      apples.push(newApple); // Add the new apple to the array
    }

    // Spawn a new power-up at a random position
    function spawnPower() {
      let newPower;
      const type = getRandomPowerType(); // Get random power type
      do {
        newPower = {
          x: getRandomInt(0, canvas.width / grid) * grid, // Random x position
          y: getRandomInt(0, canvas.height / grid) * grid, // Random y position
          color: 'magenta', // Fixed color for power-ups
          type: type // Assign type
        };
      } while (isOccupied(newPower.x, newPower.y)); // Ensure the position is not occupied
      powers.push(newPower); // Add the new power-up to the array
    }

    // Check if a position is occupied by the snake, apples, or power-ups
    function isOccupied(x, y) {
      if (snake.cells.some(cell => cell.x === x && cell.y === y)) return true; // Check if occupied by snake
      if (apples.some(apple => apple.x === x && apple.y === y)) return true; // Check if occupied by apple
      return false; // Not occupied
    }

    // Get a random color for the apple
    function getRandomAppleColor() {
      const appleColors = ['red', 'orange']; // Possible apple colors
      return appleColors[Math.floor(Math.random() * appleColors.length)]; // Return random color
    }

    // Get a random color for the snake
    function getRandomSnakeColor() {
      const snakeColors = ['teal', 'cyan']; // Possible snake colors
      return snakeColors[Math.floor(Math.random() * snakeColors.length)]; // Return random color
    }

    // Get a random power type (0, 1, or 2)
    function getRandomPowerType() {
      return Math.floor(Math.random() * 3); // Return random integer between 0 and 2
    }

    // Get a random integer between min (inclusive) and max (exclusive)
    function getRandomInt(min, max) {
      return Math.floor(Math.random() * (max - min)) + min; // Random integer calculation
    }

    document.addEventListener('keydown', (e) => {
  const currentTime = Date.now(); // Get the current time
  if (currentTime - lastDirectionChange < DIRECTION_CHANGE_COOLDOWN) {
    return; // Ignore input if within cooldown
  }

      let lastDirectionChange = 0; // Track the last direction change time
const DIRECTION_CHANGE_COOLDOWN = 100; // Time in milliseconds before another direction change is allowed

      
  switch (e.key) {
    case 'ArrowUp':
    case 'w':
      if (snake.dy === 0) {
        snake.dx = 0;
        snake.dy = -grid; // Move up
        lastDirectionChange = currentTime; // Update last direction change time
      }
      break;
    case 'ArrowDown':
    case 's':
      if (snake.dy === 0) {
        snake.dx = 0;
        snake.dy = grid; // Move down
        lastDirectionChange = currentTime; // Update last direction change time
      }
      break;
    case 'ArrowLeft':
    case 'a':
      if (snake.dx === 0) {
        snake.dx = -grid; // Move left
        snake.dy = 0;
        lastDirectionChange = currentTime; // Update last direction change time
      }
      break;
    case 'ArrowRight':
    case 'd':
      if (snake.dx === 0) {
        snake.dx = grid; // Move right
        snake.dy = 0;
        lastDirectionChange = currentTime; // Update last direction change time
      }
      break;
  }
});

    // Main game loop for updating the game state
    function loop() {
      if (++count < 1) { // Control the speed of the game loop
        return; // Skip this loop iteration
      }
      count = 0; // Reset count for next iteration

      context.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas

      // Update snake position
      snake.x += snake.dx;
      snake.y += snake.dy;

      // Wrap the snake around the canvas edges
      if (snake.x < 0) snake.x = canvas.width - grid;
      else if (snake.x >= canvas.width) snake.x = 0;
      if (snake.y < 0) snake.y = canvas.height - grid;
      else if (snake.y >= canvas.height) snake.y = 0;

      // Check for apple collision
      apples.forEach((apple, index) => {
        if (snake.x === apple.x && snake.y === apple.y) {
          score += 10; // Increase score
          updateScore(); // Update score display
          snake.maxCells++; // Increase snake length
          apples.splice(index, 1); // Remove apple from array
          spawnApple(); // Spawn new apple
        }
      });

      // Check for power-up collision
      powers.forEach((power, index) => {
        if (snake.x === power.x && snake.y === power.y) {
          applyPower(power.type); // Apply the effect of the power-up
          powers.splice(index, 1); // Remove power-up from array
        }
      });

      // Add new head to the snake
      snake.cells.unshift({ x: snake.x, y: snake.y });

      // Remove the tail if snake exceeds max length
      if (snake.cells.length > snake.maxCells) {
        snake.cells.pop();
      }

      // Check for self-collision
      for (let i = 1; i < snake.cells.length; i++) {
        if (snake.cells[i].x === snake.x && snake.cells[i].y === snake.y) {
          endGame(); // End game on collision
        }
      }

      // Draw the snake
      context.fillStyle = snakeColor; // Set snake color
      snake.cells.forEach((cell) => {
        context.fillRect(cell.x, cell.y, grid - 1, grid - 1); // Draw each segment
      });

      // Draw apples
      apples.forEach(apple => {
        context.fillStyle = apple.color; // Set apple color
        context.fillRect(apple.x, apple.y, grid - 1, grid - 1); // Draw apple
      });

      // Draw power-ups
      powers.forEach(power => {
        context.fillStyle = power.color; // Fixed to magenta
        context.fillRect(power.x, power.y, grid - 1, grid - 1); // Draw power-up
        context.fillStyle = 'white'; // Draw type number
        context.font = '12px Arial'; // Set font for type display
        context.fillText(power.type + 1, power.x + 4, power.y + 12); // Display power type
      });
    }

    // Apply the effect of a collected power-up
    function applyPower(type) {
      switch (type) {
        case POWER_TYPES.SPEED_UP: // Speed up the snake
          snakeSpeed = Math.max(1, snakeSpeed - 1); // Decrease speed
          clearInterval(gameInterval); // Clear the current game interval
          gameInterval = setInterval(loop, snakeSpeed * 100); // Reset game interval with new speed
          break;
        case POWER_TYPES.SPEED_DOWN: // Slow down the snake
          snakeSpeed = Math.min(10, snakeSpeed + 1); // Increase speed
          clearInterval(gameInterval); // Clear the current game interval
          gameInterval = setInterval(loop, snakeSpeed * 100); // Reset game interval with new speed
          break;
        case POWER_TYPES.SCORE_UP: // Increase score directly
          score += 50; // Add bonus score
          updateScore(); // Update score display
          break;
      }
    }

    // Update the displayed score
    function updateScore() {
      scoreElement.textContent = `Score: ${score}`; // Update score display
    }

    // End the game and show final score
    function endGame() {
      clearInterval(gameInterval); // Stop game interval
      clearInterval(powerIntervalId); // Stop power-up spawning
      isGameRunning = false; // Set game as not running
      canvas.style.display = 'none'; // Hide game canvas
      scoreElement.style.display = 'none'; // Hide score display
      finalScoreElement.textContent = `Final Score: ${score}`; // Display final score
      finalScoreElement.style.display = 'block'; // Show final score
      menu.style.display = 'flex'; // Show menu again
    }

    // Show game information
    function showInfo() {
      infoElement.style.display = 'block'; // Show info overlay
    }

    // Hide game information
    function hideInfo() {
      infoElement.style.display = 'none'; // Hide info overlay
    }
  </script>
</body>
</html>
